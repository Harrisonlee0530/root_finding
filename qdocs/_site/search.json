[
  {
    "objectID": "tutorial.html",
    "href": "tutorial.html",
    "title": "Tutorial",
    "section": "",
    "text": "This page demonstrates how to use the main functions in root_finding."
  },
  {
    "objectID": "tutorial.html#what-functions-are-available",
    "href": "tutorial.html#what-functions-are-available",
    "title": "Tutorial",
    "section": "What functions are available?",
    "text": "What functions are available?\nRun this to see what is exported by the package:\n```python import root_finding [x for x in dir(root_finding) if not x.startswith(“_“)]"
  },
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "Reference",
    "section": "",
    "text": "{{&lt; quartodoc &gt;}}"
  },
  {
    "objectID": "reference.html#public-api",
    "href": "reference.html#public-api",
    "title": "Reference",
    "section": "",
    "text": "{{&lt; quartodoc &gt;}}"
  },
  {
    "objectID": "reference/plot_root.html",
    "href": "reference/plot_root.html",
    "title": "plot_root",
    "section": "",
    "text": "plot_root\nA module that provides visualization tools for root finding algorithms.\n\n\n\n\n\nName\nDescription\n\n\n\n\nplot_root\nPlot a scalar function and visualize its roots using a hybrid\n\n\n\n\n\nplot_root.plot_root(\n    f,\n    dfdx,\n    xmin,\n    xmax,\n    tol1,\n    tol2,\n    max_iter1=500,\n    max_iter2=500,\n    npts=1000,\n    n=50,\n)\nPlot a scalar function and visualize its roots using a hybrid bisection-Newton root-finding algorithm.\nThis function computes the roots of a scalar function f within a given interval using the hybrid method and returns a Matplotlib figure containing the function plot and the detected roots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nScalar function to be plotted. Must accept a single scalar argument.\nrequired\n\n\ndfdx\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nxmin\nfloat\nLower bound of the plotting and root-search interval.\nrequired\n\n\nxmax\nfloat\nUpper bound of the plotting and root-search interval.\nrequired\n\n\ntol1\nfloat\nConvergence tolerance passed to the bisection-based root search stage of the hybrid method. Must be strictly positive.\nrequired\n\n\ntol2\nfloat\nRelative convergence tolerance passed to the Newton-Raphson refinement stage of the hybrid method. Must be strictly positive.\nrequired\n\n\nmax_iter1\nint\nMaximum number of iterations allowed for the bisection-based root search. Default is 500.\n500\n\n\nmax_iter2\nint\nMaximum number of iterations allowed for Newton’s method. Default is 500.\n500\n\n\nnpts\nint\nNumber of points used to discretize the interval [xmin, xmax] for plotting the function. Default is 1000.\n1000\n\n\nn\nint\nNumber of subintervals used by the bisection-based root search. Passed to the hybrid solver. Default is 50.\n50\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfig\nmatplotlib.figure.Figure\nThe Matplotlib figure object.\n\n\nax\nmatplotlib.axes.Axes\nThe Matplotlib axes containing the plot.\n\n\n\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 4\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; fig, ax = plot_root(f, df, -3, 3, 1e-6, 1e-12)\n&gt;&gt;&gt; fig.savefig(\"roots.png\")"
  },
  {
    "objectID": "reference/plot_root.html#functions",
    "href": "reference/plot_root.html#functions",
    "title": "plot_root",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nplot_root\nPlot a scalar function and visualize its roots using a hybrid\n\n\n\n\n\nplot_root.plot_root(\n    f,\n    dfdx,\n    xmin,\n    xmax,\n    tol1,\n    tol2,\n    max_iter1=500,\n    max_iter2=500,\n    npts=1000,\n    n=50,\n)\nPlot a scalar function and visualize its roots using a hybrid bisection-Newton root-finding algorithm.\nThis function computes the roots of a scalar function f within a given interval using the hybrid method and returns a Matplotlib figure containing the function plot and the detected roots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nScalar function to be plotted. Must accept a single scalar argument.\nrequired\n\n\ndfdx\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nxmin\nfloat\nLower bound of the plotting and root-search interval.\nrequired\n\n\nxmax\nfloat\nUpper bound of the plotting and root-search interval.\nrequired\n\n\ntol1\nfloat\nConvergence tolerance passed to the bisection-based root search stage of the hybrid method. Must be strictly positive.\nrequired\n\n\ntol2\nfloat\nRelative convergence tolerance passed to the Newton-Raphson refinement stage of the hybrid method. Must be strictly positive.\nrequired\n\n\nmax_iter1\nint\nMaximum number of iterations allowed for the bisection-based root search. Default is 500.\n500\n\n\nmax_iter2\nint\nMaximum number of iterations allowed for Newton’s method. Default is 500.\n500\n\n\nnpts\nint\nNumber of points used to discretize the interval [xmin, xmax] for plotting the function. Default is 1000.\n1000\n\n\nn\nint\nNumber of subintervals used by the bisection-based root search. Passed to the hybrid solver. Default is 50.\n50\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfig\nmatplotlib.figure.Figure\nThe Matplotlib figure object.\n\n\nax\nmatplotlib.axes.Axes\nThe Matplotlib axes containing the plot.\n\n\n\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 4\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; fig, ax = plot_root(f, df, -3, 3, 1e-6, 1e-12)\n&gt;&gt;&gt; fig.savefig(\"roots.png\")"
  },
  {
    "objectID": "reference/bisection.bisection.bisection.html",
    "href": "reference/bisection.bisection.bisection.html",
    "title": "bisection.bisection.bisection",
    "section": "",
    "text": "bisection.bisection.bisection(f, xmin, xmax, tol=1e-09, max_iter=500)\nFind roots of a scalar function using Bisection.\n\n\nf : callable Function whose root is sought. Must accept a single scalar argument. xmin : float Lower bound of the initial interval. xmax : float Upper bound of the initial interval. tol : float, optional Absolute convergence tolerance for the bisection method. The method converges when |xmax - xmin| &lt; tol. The default value is 1e-9. max_iter : int, optional maximum number of iterations allowable. Default is 500.\n\n\n\nroot : float The estimated root of the function f.\n\n\n\nValueError\n    If the initial interval [xmin, xmax] does not bracket the root\n    (i.e., if f(xmin) and f(xmax) have the same sign).\nRuntimeError\n    If the algorithm fails to converge within `max_iter` iterations.\nTypeError\n    If the inputs are not of the expected types.\n\n\n\nIn general the bisection method requires that the root to be enclosed by the initial interval [xmin, xmax], i.e., f(xmin) * f(xmax) &lt; 0. It is used to produce an estimate that lies sufficiently close to the root when the relative convergence criteria tol is satisfied:\nWhere | (xmax - xmin) | &lt; tol\n`\n\n\n\n&gt;&gt;&gt; root = bisection(lambda x: 3*x**3 + 4*x**2 - 2*x - 2, 0, 2, max_iter = 500)\n&gt;&gt;&gt; print(f\"{root:.5f}\")\n    0.74827"
  },
  {
    "objectID": "reference/bisection.bisection.bisection.html#parameters",
    "href": "reference/bisection.bisection.bisection.html#parameters",
    "title": "bisection.bisection.bisection",
    "section": "",
    "text": "f : callable Function whose root is sought. Must accept a single scalar argument. xmin : float Lower bound of the initial interval. xmax : float Upper bound of the initial interval. tol : float, optional Absolute convergence tolerance for the bisection method. The method converges when |xmax - xmin| &lt; tol. The default value is 1e-9. max_iter : int, optional maximum number of iterations allowable. Default is 500."
  },
  {
    "objectID": "reference/bisection.bisection.bisection.html#returns",
    "href": "reference/bisection.bisection.bisection.html#returns",
    "title": "bisection.bisection.bisection",
    "section": "",
    "text": "root : float The estimated root of the function f."
  },
  {
    "objectID": "reference/bisection.bisection.bisection.html#raises",
    "href": "reference/bisection.bisection.bisection.html#raises",
    "title": "bisection.bisection.bisection",
    "section": "",
    "text": "ValueError\n    If the initial interval [xmin, xmax] does not bracket the root\n    (i.e., if f(xmin) and f(xmax) have the same sign).\nRuntimeError\n    If the algorithm fails to converge within `max_iter` iterations.\nTypeError\n    If the inputs are not of the expected types."
  },
  {
    "objectID": "reference/bisection.bisection.bisection.html#notes",
    "href": "reference/bisection.bisection.bisection.html#notes",
    "title": "bisection.bisection.bisection",
    "section": "",
    "text": "In general the bisection method requires that the root to be enclosed by the initial interval [xmin, xmax], i.e., f(xmin) * f(xmax) &lt; 0. It is used to produce an estimate that lies sufficiently close to the root when the relative convergence criteria tol is satisfied:\nWhere | (xmax - xmin) | &lt; tol\n`"
  },
  {
    "objectID": "reference/bisection.bisection.bisection.html#examples",
    "href": "reference/bisection.bisection.bisection.html#examples",
    "title": "bisection.bisection.bisection",
    "section": "",
    "text": "&gt;&gt;&gt; root = bisection(lambda x: 3*x**3 + 4*x**2 - 2*x - 2, 0, 2, max_iter = 500)\n&gt;&gt;&gt; print(f\"{root:.5f}\")\n    0.74827"
  },
  {
    "objectID": "reference/bisection.bisection_find_roots.bisection_find_roots.html",
    "href": "reference/bisection.bisection_find_roots.bisection_find_roots.html",
    "title": "bisection.bisection_find_roots.bisection_find_roots",
    "section": "",
    "text": "bisection.bisection_find_roots.bisection_find_roots(\n    f,\n    xmin,\n    xmax,\n    tol=1e-06,\n    max_iter=100,\n    N=100,\n)\nFind multiple roots of a scalar function using the bisection method.\nSplit [xmin,xmax] into N-1 intervals and check for roots in each interval.\n\n\nf : callable Function whose root is sought. Must accept a single scalar argument. xmin : float Lower bound of the initial interval. xmax : float Upper bound of the initial interval. tol : float, optional Absolute convergence tolerance for the bisection method. The method converges when |xmax - xmin| &lt; tol. The default value is 1e-6. max_iter : int, optional maximum number of iterations allowable. Default is 100. N : int, optional Use to set number of intervals. Default is 100 (99 intervals).\n\n\n\nroots : numpy array of floats The estimated roots of the function f.\n\n\n\nRuntimeError\n    If the algorithm fails to converge within `max_iter` iterations.\nTypeError\n    If the inputs are not of the expected types.\n\n\n\nThe bisection method requires that the root to be enclosed by the initial interval [xmin, xmax], i.e., f(xmin) * f(xmax) &lt; 0. It is used to produce an estimate that lies sufficiently close to the root when the relative convergence criteria tol is satisfied:\nWhere | (xmax - xmin) | &lt; tol\nIn general when searching for multiple root value the bisection method is NOT guaranteed to find roots, and is NOT guaranteed to find roots with multiplicity greater than 1 (e.g. roots of x**2)\nThis function may return duplicate roots. `\n\n\n\n&gt;&gt;&gt; roots = bisection_find_roots(lambda x: x**2 - 4, -3, 3, N=100)\n&gt;&gt;&gt; print(roots)\n    [-2.  2.]\n\n# Bisection method cannot find roots\n&gt;&gt;&gt; roots = bisection_find_roots(lambda x: x**2 - 0.0001, -3, 3, tol=1e-9, max_iter = 1000, N=100)\n&gt;&gt;&gt; print(roots)\n    []\n\n# Smaller intervals now find roots\n&gt;&gt;&gt; roots = bisection_find_roots(lambda x: x**2 - 0.0001, -3, 3, tol=1e-9, max_iter = 1000, N=1000)\n&gt;&gt;&gt; print(roots)\n    [-0.01  0.01]\n\n# Returns duplicate roots\n&gt;&gt;&gt; roots = bisection_find_roots(lambda x: x**2 - 1, -3, 3, tol=1e-9, N=100)\n&gt;&gt;&gt; print(roots)\n    [-1. -1.  1.  1.]"
  },
  {
    "objectID": "reference/bisection.bisection_find_roots.bisection_find_roots.html#parameters",
    "href": "reference/bisection.bisection_find_roots.bisection_find_roots.html#parameters",
    "title": "bisection.bisection_find_roots.bisection_find_roots",
    "section": "",
    "text": "f : callable Function whose root is sought. Must accept a single scalar argument. xmin : float Lower bound of the initial interval. xmax : float Upper bound of the initial interval. tol : float, optional Absolute convergence tolerance for the bisection method. The method converges when |xmax - xmin| &lt; tol. The default value is 1e-6. max_iter : int, optional maximum number of iterations allowable. Default is 100. N : int, optional Use to set number of intervals. Default is 100 (99 intervals)."
  },
  {
    "objectID": "reference/bisection.bisection_find_roots.bisection_find_roots.html#returns",
    "href": "reference/bisection.bisection_find_roots.bisection_find_roots.html#returns",
    "title": "bisection.bisection_find_roots.bisection_find_roots",
    "section": "",
    "text": "roots : numpy array of floats The estimated roots of the function f."
  },
  {
    "objectID": "reference/bisection.bisection_find_roots.bisection_find_roots.html#raises",
    "href": "reference/bisection.bisection_find_roots.bisection_find_roots.html#raises",
    "title": "bisection.bisection_find_roots.bisection_find_roots",
    "section": "",
    "text": "RuntimeError\n    If the algorithm fails to converge within `max_iter` iterations.\nTypeError\n    If the inputs are not of the expected types."
  },
  {
    "objectID": "reference/bisection.bisection_find_roots.bisection_find_roots.html#notes",
    "href": "reference/bisection.bisection_find_roots.bisection_find_roots.html#notes",
    "title": "bisection.bisection_find_roots.bisection_find_roots",
    "section": "",
    "text": "The bisection method requires that the root to be enclosed by the initial interval [xmin, xmax], i.e., f(xmin) * f(xmax) &lt; 0. It is used to produce an estimate that lies sufficiently close to the root when the relative convergence criteria tol is satisfied:\nWhere | (xmax - xmin) | &lt; tol\nIn general when searching for multiple root value the bisection method is NOT guaranteed to find roots, and is NOT guaranteed to find roots with multiplicity greater than 1 (e.g. roots of x**2)\nThis function may return duplicate roots. `"
  },
  {
    "objectID": "reference/bisection.bisection_find_roots.bisection_find_roots.html#examples",
    "href": "reference/bisection.bisection_find_roots.bisection_find_roots.html#examples",
    "title": "bisection.bisection_find_roots.bisection_find_roots",
    "section": "",
    "text": "&gt;&gt;&gt; roots = bisection_find_roots(lambda x: x**2 - 4, -3, 3, N=100)\n&gt;&gt;&gt; print(roots)\n    [-2.  2.]\n\n# Bisection method cannot find roots\n&gt;&gt;&gt; roots = bisection_find_roots(lambda x: x**2 - 0.0001, -3, 3, tol=1e-9, max_iter = 1000, N=100)\n&gt;&gt;&gt; print(roots)\n    []\n\n# Smaller intervals now find roots\n&gt;&gt;&gt; roots = bisection_find_roots(lambda x: x**2 - 0.0001, -3, 3, tol=1e-9, max_iter = 1000, N=1000)\n&gt;&gt;&gt; print(roots)\n    [-0.01  0.01]\n\n# Returns duplicate roots\n&gt;&gt;&gt; roots = bisection_find_roots(lambda x: x**2 - 1, -3, 3, tol=1e-9, N=100)\n&gt;&gt;&gt; print(roots)\n    [-1. -1.  1.  1.]"
  },
  {
    "objectID": "reference/newton1d.html",
    "href": "reference/newton1d.html",
    "title": "newton1d",
    "section": "",
    "text": "newton1d\nA module that implements a root finding algorithm using Newton-Raphson method.\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton1d\nFind roots of a scalar function using Newton–Raphson.\n\n\n\n\n\nnewton1d.newton1d(f, df, x0, tol1, max_iter=1000)\nFind roots of a scalar function using Newton–Raphson.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nFunction whose root is sought. Must accept a single scalar argument.\nrequired\n\n\ndf\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nx0\nfloat or Sequence[float]\nInitial guesses for the root.\nrequired\n\n\ntol1\nfloat\nRelative convergence tolerance for the Newton–Raphson method. Must be strictly positive.\nrequired\n\n\nmax_iter\nint\nMaximum number of iterations before declaring non-convergence.\n100\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx_arr\nSequence[float]\nEstimated roots of the function f.\n\n\n\n\n\n\nThe Newton–Raphson method updates the current estimate using the local linear approximation of f at the current point:\nx_{n+1} = x_n - f(x_n) / df(x_n).\nConvergence is declared when the step size is sufficiently small in a relative sense:\n|x_{n+1} - x_n| &lt;= tol1 * max(1, |x_{n+1}|).\nThis is numerically safer than |(x_{n+1}-x_n)/x_{n+1}| because it avoids division by zero when x_{n+1} = 0.\nThe method often converges rapidly when x0 is sufficiently close to the true root and df(x) is well-behaved, but it may fail when df(x_n) = 0 (or very close to zero) or when the iterates diverge.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTypeError\nIf f or df is not callable.\n\n\n\nValueError\nIf tol1 &lt;= 0, max_iter &lt;= 0, x0 is not finite, or df(x) is too close to zero during iteration.\n\n\n\nRuntimeError\nIf the method does not converge within max_iter iterations.\n\n\n\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 2\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; root = newton1d(f, df, 1.0, 1e-12)\n&gt;&gt;&gt; abs(root - 2**0.5) &lt; 1e-10\nTrue"
  },
  {
    "objectID": "reference/newton1d.html#functions",
    "href": "reference/newton1d.html#functions",
    "title": "newton1d",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton1d\nFind roots of a scalar function using Newton–Raphson.\n\n\n\n\n\nnewton1d.newton1d(f, df, x0, tol1, max_iter=1000)\nFind roots of a scalar function using Newton–Raphson.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nFunction whose root is sought. Must accept a single scalar argument.\nrequired\n\n\ndf\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nx0\nfloat or Sequence[float]\nInitial guesses for the root.\nrequired\n\n\ntol1\nfloat\nRelative convergence tolerance for the Newton–Raphson method. Must be strictly positive.\nrequired\n\n\nmax_iter\nint\nMaximum number of iterations before declaring non-convergence.\n100\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx_arr\nSequence[float]\nEstimated roots of the function f.\n\n\n\n\n\n\nThe Newton–Raphson method updates the current estimate using the local linear approximation of f at the current point:\nx_{n+1} = x_n - f(x_n) / df(x_n).\nConvergence is declared when the step size is sufficiently small in a relative sense:\n|x_{n+1} - x_n| &lt;= tol1 * max(1, |x_{n+1}|).\nThis is numerically safer than |(x_{n+1}-x_n)/x_{n+1}| because it avoids division by zero when x_{n+1} = 0.\nThe method often converges rapidly when x0 is sufficiently close to the true root and df(x) is well-behaved, but it may fail when df(x_n) = 0 (or very close to zero) or when the iterates diverge.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTypeError\nIf f or df is not callable.\n\n\n\nValueError\nIf tol1 &lt;= 0, max_iter &lt;= 0, x0 is not finite, or df(x) is too close to zero during iteration.\n\n\n\nRuntimeError\nIf the method does not converge within max_iter iterations.\n\n\n\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 2\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; root = newton1d(f, df, 1.0, 1e-12)\n&gt;&gt;&gt; abs(root - 2**0.5) &lt; 1e-10\nTrue"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "Root finding using bisection method\n\n\n\nbisection.bisection.bisection\nFind roots of a scalar function using Bisection.\n\n\nbisection.bisection_find_roots.bisection_find_roots\nFind multiple roots of a scalar function using the bisection method.\n\n\n\n\n\n\nRoot finding using Newton-Raphson method\n\n\n\nnewton1d.newton1d\nFind roots of a scalar function using Newton–Raphson.\n\n\n\n\n\n\nRoot finding using hybrid Bisection-Newton method\n\n\n\nhybrid.hybrid\nFind multiple roots of a scalar function using a hybrid\n\n\n\n\n\n\nTools for plotting root finding results\n\n\n\nplot_root.plot_root\nPlot a scalar function and visualize its roots using a hybrid"
  },
  {
    "objectID": "reference/index.html#bisection-method",
    "href": "reference/index.html#bisection-method",
    "title": "API Reference",
    "section": "",
    "text": "Root finding using bisection method\n\n\n\nbisection.bisection.bisection\nFind roots of a scalar function using Bisection.\n\n\nbisection.bisection_find_roots.bisection_find_roots\nFind multiple roots of a scalar function using the bisection method."
  },
  {
    "objectID": "reference/index.html#newtons-method",
    "href": "reference/index.html#newtons-method",
    "title": "API Reference",
    "section": "",
    "text": "Root finding using Newton-Raphson method\n\n\n\nnewton1d.newton1d\nFind roots of a scalar function using Newton–Raphson."
  },
  {
    "objectID": "reference/index.html#hybrid-method",
    "href": "reference/index.html#hybrid-method",
    "title": "API Reference",
    "section": "",
    "text": "Root finding using hybrid Bisection-Newton method\n\n\n\nhybrid.hybrid\nFind multiple roots of a scalar function using a hybrid"
  },
  {
    "objectID": "reference/index.html#plotting",
    "href": "reference/index.html#plotting",
    "title": "API Reference",
    "section": "",
    "text": "Visualization tools for root finding\n\n\n\nplot_root\nA module that provides visualization tools for root finding algorithms."
  },
  {
    "objectID": "reference/hybrid.html",
    "href": "reference/hybrid.html",
    "title": "hybrid",
    "section": "",
    "text": "hybrid\nA module that implements a root finding algorithm using Bisection and Newton-Raphson method combined.\n\n\n\n\n\nName\nDescription\n\n\n\n\nhybrid\nFind multiple roots of a scalar function using a hybrid\n\n\n\n\n\nhybrid.hybrid(\n    f,\n    dfdx,\n    xmin,\n    xmax,\n    tol1,\n    tol2,\n    max_iter1=500,\n    max_iter2=500,\n    n=50,\n)\nFind multiple roots of a scalar function using a hybrid Bisection-Newton method.\nThis algorithm combines a robust bisection-based root searching stage with Newton-Raphson refinement to efficiently locate all detectable roots within a given interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nFunction whose roots are sought. Must accept a single scalar argument.\nrequired\n\n\ndfdx\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nxmin\nfloat\nLower bound of the search interval.\nrequired\n\n\nxmax\nfloat\nUpper bound of the search interval.\nrequired\n\n\ntol1\nfloat\nAbsolute or relative convergence tolerance used by the bisection-based root search. This tolerance controls the accuracy of the initial guesses passed to Newton’s method and must be strictly positive.\nrequired\n\n\ntol2\nfloat\nRelative convergence tolerance used by the Newton-Raphson method. Must be strictly positive.\nrequired\n\n\nmax_iter1\nint\nMaximum number of iteration for bisection method, Default = 500\n500\n\n\nmax_iter2\nint\nMaximum number of iteration for Newton’s method, Default = 500\n500\n\n\nn\nint\nnumber of initial guess if bisection fails for some reason (ex: when f(x) = x^2)\n50\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nroots\nSequence[float]\nA sequence of estimated roots of the function f within the interval [xmin, xmax]. Only roots for which Newton’s method converges successfully are returned. The output may be empty if no convergent roots are found.\n\n\n\n\n\n\nThe hybrid algorithm proceeds in two stages:\n\nBisection-based root search\nThe interval [xmin, xmax] is subdivided and examined for sign changes of f. Each detected sign change (or exact zero) produces an initial root estimate using the bisection method via bisection_find_roots.\nThis stage is robust but may:\n\nMiss roots of even multiplicity\nMiss roots if the subdivision is too coarse\nReturn duplicate or closely spaced root estimates\n\nNewton-Raphson refinement\nEach bisection-derived estimate is passed as an initial guess to newton1d, which rapidly refines the root when the derivative is well-behaved.\nNewton’s method may fail to converge if:\n\nThe derivative is zero or nearly zero\nThe initial guess is too far from a true root\nThe iterates diverge or become non-finite\n\n\nDuplicate roots produced by either stage may be filtered using the Newton convergence tolerance tol2.\nConvergence for Newton’s method is declared when:\n|x_{n+1} - x_n| &lt;= tol2 * max(1, |x_{n+1}|).\nThis hybrid approach improves robustness compared to Newton’s method alone while achieving faster convergence than pure bisection.\n\n\n\nbisection_find_roots : Bisection-based root search for detecting multiple candidate roots. newton1d : Newton-Raphson method for fast local root refinement.\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 4\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; roots = hybrid(f, df, -3, 3, tol1=1e-6, tol2=1e-12)\n&gt;&gt;&gt; sorted(roots)\n[-2.0, 2.0]\n&gt;&gt;&gt; f = lambda x: x**3 - x\n&gt;&gt;&gt; df = lambda x: 3*x**2 - 1\n&gt;&gt;&gt; roots = hybrid(f, df, -2, 2, tol1=1e-6, tol2=1e-12)\n&gt;&gt;&gt; sorted(roots)\n[-1.0, 0.0, 1.0]"
  },
  {
    "objectID": "reference/hybrid.html#functions",
    "href": "reference/hybrid.html#functions",
    "title": "hybrid",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhybrid\nFind multiple roots of a scalar function using a hybrid\n\n\n\n\n\nhybrid.hybrid(\n    f,\n    dfdx,\n    xmin,\n    xmax,\n    tol1,\n    tol2,\n    max_iter1=500,\n    max_iter2=500,\n    n=50,\n)\nFind multiple roots of a scalar function using a hybrid Bisection-Newton method.\nThis algorithm combines a robust bisection-based root searching stage with Newton-Raphson refinement to efficiently locate all detectable roots within a given interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nFunction whose roots are sought. Must accept a single scalar argument.\nrequired\n\n\ndfdx\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nxmin\nfloat\nLower bound of the search interval.\nrequired\n\n\nxmax\nfloat\nUpper bound of the search interval.\nrequired\n\n\ntol1\nfloat\nAbsolute or relative convergence tolerance used by the bisection-based root search. This tolerance controls the accuracy of the initial guesses passed to Newton’s method and must be strictly positive.\nrequired\n\n\ntol2\nfloat\nRelative convergence tolerance used by the Newton-Raphson method. Must be strictly positive.\nrequired\n\n\nmax_iter1\nint\nMaximum number of iteration for bisection method, Default = 500\n500\n\n\nmax_iter2\nint\nMaximum number of iteration for Newton’s method, Default = 500\n500\n\n\nn\nint\nnumber of initial guess if bisection fails for some reason (ex: when f(x) = x^2)\n50\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nroots\nSequence[float]\nA sequence of estimated roots of the function f within the interval [xmin, xmax]. Only roots for which Newton’s method converges successfully are returned. The output may be empty if no convergent roots are found.\n\n\n\n\n\n\nThe hybrid algorithm proceeds in two stages:\n\nBisection-based root search\nThe interval [xmin, xmax] is subdivided and examined for sign changes of f. Each detected sign change (or exact zero) produces an initial root estimate using the bisection method via bisection_find_roots.\nThis stage is robust but may:\n\nMiss roots of even multiplicity\nMiss roots if the subdivision is too coarse\nReturn duplicate or closely spaced root estimates\n\nNewton-Raphson refinement\nEach bisection-derived estimate is passed as an initial guess to newton1d, which rapidly refines the root when the derivative is well-behaved.\nNewton’s method may fail to converge if:\n\nThe derivative is zero or nearly zero\nThe initial guess is too far from a true root\nThe iterates diverge or become non-finite\n\n\nDuplicate roots produced by either stage may be filtered using the Newton convergence tolerance tol2.\nConvergence for Newton’s method is declared when:\n|x_{n+1} - x_n| &lt;= tol2 * max(1, |x_{n+1}|).\nThis hybrid approach improves robustness compared to Newton’s method alone while achieving faster convergence than pure bisection.\n\n\n\nbisection_find_roots : Bisection-based root search for detecting multiple candidate roots. newton1d : Newton-Raphson method for fast local root refinement.\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 4\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; roots = hybrid(f, df, -3, 3, tol1=1e-6, tol2=1e-12)\n&gt;&gt;&gt; sorted(roots)\n[-2.0, 2.0]\n&gt;&gt;&gt; f = lambda x: x**3 - x\n&gt;&gt;&gt; df = lambda x: 3*x**2 - 1\n&gt;&gt;&gt; roots = hybrid(f, df, -2, 2, tol1=1e-6, tol2=1e-12)\n&gt;&gt;&gt; sorted(roots)\n[-1.0, 0.0, 1.0]"
  },
  {
    "objectID": "reference/newton1d.newton1d.html",
    "href": "reference/newton1d.newton1d.html",
    "title": "newton1d.newton1d",
    "section": "",
    "text": "newton1d.newton1d(f, df, x0, tol1, max_iter=1000)\nFind roots of a scalar function using Newton–Raphson.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nFunction whose root is sought. Must accept a single scalar argument.\nrequired\n\n\ndf\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nx0\nfloat or Sequence[float]\nInitial guesses for the root.\nrequired\n\n\ntol1\nfloat\nRelative convergence tolerance for the Newton–Raphson method. Must be strictly positive.\nrequired\n\n\nmax_iter\nint\nMaximum number of iterations before declaring non-convergence.\n100\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx_arr\nSequence[float]\nEstimated roots of the function f.\n\n\n\n\n\n\nThe Newton–Raphson method updates the current estimate using the local linear approximation of f at the current point:\nx_{n+1} = x_n - f(x_n) / df(x_n).\nConvergence is declared when the step size is sufficiently small in a relative sense:\n|x_{n+1} - x_n| &lt;= tol1 * max(1, |x_{n+1}|).\nThis is numerically safer than |(x_{n+1}-x_n)/x_{n+1}| because it avoids division by zero when x_{n+1} = 0.\nThe method often converges rapidly when x0 is sufficiently close to the true root and df(x) is well-behaved, but it may fail when df(x_n) = 0 (or very close to zero) or when the iterates diverge.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTypeError\nIf f or df is not callable.\n\n\n\nValueError\nIf tol1 &lt;= 0, max_iter &lt;= 0, x0 is not finite, or df(x) is too close to zero during iteration.\n\n\n\nRuntimeError\nIf the method does not converge within max_iter iterations.\n\n\n\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 2\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; root = newton1d(f, df, 1.0, 1e-12)\n&gt;&gt;&gt; abs(root - 2**0.5) &lt; 1e-10\nTrue"
  },
  {
    "objectID": "reference/newton1d.newton1d.html#parameters",
    "href": "reference/newton1d.newton1d.html#parameters",
    "title": "newton1d.newton1d",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nFunction whose root is sought. Must accept a single scalar argument.\nrequired\n\n\ndf\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nx0\nfloat or Sequence[float]\nInitial guesses for the root.\nrequired\n\n\ntol1\nfloat\nRelative convergence tolerance for the Newton–Raphson method. Must be strictly positive.\nrequired\n\n\nmax_iter\nint\nMaximum number of iterations before declaring non-convergence.\n100"
  },
  {
    "objectID": "reference/newton1d.newton1d.html#returns",
    "href": "reference/newton1d.newton1d.html#returns",
    "title": "newton1d.newton1d",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nx_arr\nSequence[float]\nEstimated roots of the function f."
  },
  {
    "objectID": "reference/newton1d.newton1d.html#notes",
    "href": "reference/newton1d.newton1d.html#notes",
    "title": "newton1d.newton1d",
    "section": "",
    "text": "The Newton–Raphson method updates the current estimate using the local linear approximation of f at the current point:\nx_{n+1} = x_n - f(x_n) / df(x_n).\nConvergence is declared when the step size is sufficiently small in a relative sense:\n|x_{n+1} - x_n| &lt;= tol1 * max(1, |x_{n+1}|).\nThis is numerically safer than |(x_{n+1}-x_n)/x_{n+1}| because it avoids division by zero when x_{n+1} = 0.\nThe method often converges rapidly when x0 is sufficiently close to the true root and df(x) is well-behaved, but it may fail when df(x_n) = 0 (or very close to zero) or when the iterates diverge."
  },
  {
    "objectID": "reference/newton1d.newton1d.html#raises",
    "href": "reference/newton1d.newton1d.html#raises",
    "title": "newton1d.newton1d",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTypeError\nIf f or df is not callable.\n\n\n\nValueError\nIf tol1 &lt;= 0, max_iter &lt;= 0, x0 is not finite, or df(x) is too close to zero during iteration.\n\n\n\nRuntimeError\nIf the method does not converge within max_iter iterations."
  },
  {
    "objectID": "reference/newton1d.newton1d.html#examples",
    "href": "reference/newton1d.newton1d.html#examples",
    "title": "newton1d.newton1d",
    "section": "",
    "text": "&gt;&gt;&gt; f = lambda x: x**2 - 2\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; root = newton1d(f, df, 1.0, 1e-12)\n&gt;&gt;&gt; abs(root - 2**0.5) &lt; 1e-10\nTrue"
  },
  {
    "objectID": "reference/index.html#visualization",
    "href": "reference/index.html#visualization",
    "title": "API Reference",
    "section": "",
    "text": "Tools for plotting root finding results\n\n\n\nplot_root.plot_root\nPlot a scalar function and visualize its roots using a hybrid"
  },
  {
    "objectID": "reference/plot_root.plot_root.html",
    "href": "reference/plot_root.plot_root.html",
    "title": "plot_root.plot_root",
    "section": "",
    "text": "plot_root.plot_root(\n    f,\n    dfdx,\n    xmin,\n    xmax,\n    tol1,\n    tol2,\n    max_iter1=500,\n    max_iter2=500,\n    npts=1000,\n    n=50,\n)\nPlot a scalar function and visualize its roots using a hybrid bisection-Newton root-finding algorithm.\nThis function computes the roots of a scalar function f within a given interval using the hybrid method and returns a Matplotlib figure containing the function plot and the detected roots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nScalar function to be plotted. Must accept a single scalar argument.\nrequired\n\n\ndfdx\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nxmin\nfloat\nLower bound of the plotting and root-search interval.\nrequired\n\n\nxmax\nfloat\nUpper bound of the plotting and root-search interval.\nrequired\n\n\ntol1\nfloat\nConvergence tolerance passed to the bisection-based root search stage of the hybrid method. Must be strictly positive.\nrequired\n\n\ntol2\nfloat\nRelative convergence tolerance passed to the Newton-Raphson refinement stage of the hybrid method. Must be strictly positive.\nrequired\n\n\nmax_iter1\nint\nMaximum number of iterations allowed for the bisection-based root search. Default is 500.\n500\n\n\nmax_iter2\nint\nMaximum number of iterations allowed for Newton’s method. Default is 500.\n500\n\n\nnpts\nint\nNumber of points used to discretize the interval [xmin, xmax] for plotting the function. Default is 1000.\n1000\n\n\nn\nint\nNumber of subintervals used by the bisection-based root search. Passed to the hybrid solver. Default is 50.\n50\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfig\nmatplotlib.figure.Figure\nThe Matplotlib figure object.\n\n\nax\nmatplotlib.axes.Axes\nThe Matplotlib axes containing the plot.\n\n\n\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 4\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; fig, ax = plot_root(f, df, -3, 3, 1e-6, 1e-12)\n&gt;&gt;&gt; fig.savefig(\"roots.png\")"
  },
  {
    "objectID": "reference/plot_root.plot_root.html#parameters",
    "href": "reference/plot_root.plot_root.html#parameters",
    "title": "plot_root.plot_root",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nScalar function to be plotted. Must accept a single scalar argument.\nrequired\n\n\ndfdx\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nxmin\nfloat\nLower bound of the plotting and root-search interval.\nrequired\n\n\nxmax\nfloat\nUpper bound of the plotting and root-search interval.\nrequired\n\n\ntol1\nfloat\nConvergence tolerance passed to the bisection-based root search stage of the hybrid method. Must be strictly positive.\nrequired\n\n\ntol2\nfloat\nRelative convergence tolerance passed to the Newton-Raphson refinement stage of the hybrid method. Must be strictly positive.\nrequired\n\n\nmax_iter1\nint\nMaximum number of iterations allowed for the bisection-based root search. Default is 500.\n500\n\n\nmax_iter2\nint\nMaximum number of iterations allowed for Newton’s method. Default is 500.\n500\n\n\nnpts\nint\nNumber of points used to discretize the interval [xmin, xmax] for plotting the function. Default is 1000.\n1000\n\n\nn\nint\nNumber of subintervals used by the bisection-based root search. Passed to the hybrid solver. Default is 50.\n50"
  },
  {
    "objectID": "reference/plot_root.plot_root.html#returns",
    "href": "reference/plot_root.plot_root.html#returns",
    "title": "plot_root.plot_root",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nfig\nmatplotlib.figure.Figure\nThe Matplotlib figure object.\n\n\nax\nmatplotlib.axes.Axes\nThe Matplotlib axes containing the plot."
  },
  {
    "objectID": "reference/plot_root.plot_root.html#examples",
    "href": "reference/plot_root.plot_root.html#examples",
    "title": "plot_root.plot_root",
    "section": "",
    "text": "&gt;&gt;&gt; f = lambda x: x**2 - 4\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; fig, ax = plot_root(f, df, -3, 3, 1e-6, 1e-12)\n&gt;&gt;&gt; fig.savefig(\"roots.png\")"
  },
  {
    "objectID": "reference/hybrid.hybrid.html",
    "href": "reference/hybrid.hybrid.html",
    "title": "hybrid.hybrid",
    "section": "",
    "text": "hybrid.hybrid(\n    f,\n    dfdx,\n    xmin,\n    xmax,\n    tol1,\n    tol2,\n    max_iter1=500,\n    max_iter2=500,\n    n=50,\n)\nFind multiple roots of a scalar function using a hybrid Bisection-Newton method.\nThis algorithm combines a robust bisection-based root searching stage with Newton-Raphson refinement to efficiently locate all detectable roots within a given interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nFunction whose roots are sought. Must accept a single scalar argument.\nrequired\n\n\ndfdx\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nxmin\nfloat\nLower bound of the search interval.\nrequired\n\n\nxmax\nfloat\nUpper bound of the search interval.\nrequired\n\n\ntol1\nfloat\nAbsolute or relative convergence tolerance used by the bisection-based root search. This tolerance controls the accuracy of the initial guesses passed to Newton’s method and must be strictly positive.\nrequired\n\n\ntol2\nfloat\nRelative convergence tolerance used by the Newton-Raphson method. Must be strictly positive.\nrequired\n\n\nmax_iter1\nint\nMaximum number of iteration for bisection method, Default = 500\n500\n\n\nmax_iter2\nint\nMaximum number of iteration for Newton’s method, Default = 500\n500\n\n\nn\nint\nnumber of initial guess if bisection fails for some reason (ex: when f(x) = x^2)\n50\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nroots\nSequence[float]\nA sequence of estimated roots of the function f within the interval [xmin, xmax]. Only roots for which Newton’s method converges successfully are returned. The output may be empty if no convergent roots are found.\n\n\n\n\n\n\nThe hybrid algorithm proceeds in two stages:\n\nBisection-based root search\nThe interval [xmin, xmax] is subdivided and examined for sign changes of f. Each detected sign change (or exact zero) produces an initial root estimate using the bisection method via bisection_find_roots.\nThis stage is robust but may:\n\nMiss roots of even multiplicity\nMiss roots if the subdivision is too coarse\nReturn duplicate or closely spaced root estimates\n\nNewton-Raphson refinement\nEach bisection-derived estimate is passed as an initial guess to newton1d, which rapidly refines the root when the derivative is well-behaved.\nNewton’s method may fail to converge if:\n\nThe derivative is zero or nearly zero\nThe initial guess is too far from a true root\nThe iterates diverge or become non-finite\n\n\nDuplicate roots produced by either stage may be filtered using the Newton convergence tolerance tol2.\nConvergence for Newton’s method is declared when:\n|x_{n+1} - x_n| &lt;= tol2 * max(1, |x_{n+1}|).\nThis hybrid approach improves robustness compared to Newton’s method alone while achieving faster convergence than pure bisection.\n\n\n\nbisection_find_roots : Bisection-based root search for detecting multiple candidate roots. newton1d : Newton-Raphson method for fast local root refinement.\n\n\n\n&gt;&gt;&gt; f = lambda x: x**2 - 4\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; roots = hybrid(f, df, -3, 3, tol1=1e-6, tol2=1e-12)\n&gt;&gt;&gt; sorted(roots)\n[-2.0, 2.0]\n&gt;&gt;&gt; f = lambda x: x**3 - x\n&gt;&gt;&gt; df = lambda x: 3*x**2 - 1\n&gt;&gt;&gt; roots = hybrid(f, df, -2, 2, tol1=1e-6, tol2=1e-12)\n&gt;&gt;&gt; sorted(roots)\n[-1.0, 0.0, 1.0]"
  },
  {
    "objectID": "reference/hybrid.hybrid.html#parameters",
    "href": "reference/hybrid.hybrid.html#parameters",
    "title": "hybrid.hybrid",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nf\ncallable\nFunction whose roots are sought. Must accept a single scalar argument.\nrequired\n\n\ndfdx\ncallable\nDerivative of f. Must accept a single scalar argument.\nrequired\n\n\nxmin\nfloat\nLower bound of the search interval.\nrequired\n\n\nxmax\nfloat\nUpper bound of the search interval.\nrequired\n\n\ntol1\nfloat\nAbsolute or relative convergence tolerance used by the bisection-based root search. This tolerance controls the accuracy of the initial guesses passed to Newton’s method and must be strictly positive.\nrequired\n\n\ntol2\nfloat\nRelative convergence tolerance used by the Newton-Raphson method. Must be strictly positive.\nrequired\n\n\nmax_iter1\nint\nMaximum number of iteration for bisection method, Default = 500\n500\n\n\nmax_iter2\nint\nMaximum number of iteration for Newton’s method, Default = 500\n500\n\n\nn\nint\nnumber of initial guess if bisection fails for some reason (ex: when f(x) = x^2)\n50"
  },
  {
    "objectID": "reference/hybrid.hybrid.html#returns",
    "href": "reference/hybrid.hybrid.html#returns",
    "title": "hybrid.hybrid",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nroots\nSequence[float]\nA sequence of estimated roots of the function f within the interval [xmin, xmax]. Only roots for which Newton’s method converges successfully are returned. The output may be empty if no convergent roots are found."
  },
  {
    "objectID": "reference/hybrid.hybrid.html#notes",
    "href": "reference/hybrid.hybrid.html#notes",
    "title": "hybrid.hybrid",
    "section": "",
    "text": "The hybrid algorithm proceeds in two stages:\n\nBisection-based root search\nThe interval [xmin, xmax] is subdivided and examined for sign changes of f. Each detected sign change (or exact zero) produces an initial root estimate using the bisection method via bisection_find_roots.\nThis stage is robust but may:\n\nMiss roots of even multiplicity\nMiss roots if the subdivision is too coarse\nReturn duplicate or closely spaced root estimates\n\nNewton-Raphson refinement\nEach bisection-derived estimate is passed as an initial guess to newton1d, which rapidly refines the root when the derivative is well-behaved.\nNewton’s method may fail to converge if:\n\nThe derivative is zero or nearly zero\nThe initial guess is too far from a true root\nThe iterates diverge or become non-finite\n\n\nDuplicate roots produced by either stage may be filtered using the Newton convergence tolerance tol2.\nConvergence for Newton’s method is declared when:\n|x_{n+1} - x_n| &lt;= tol2 * max(1, |x_{n+1}|).\nThis hybrid approach improves robustness compared to Newton’s method alone while achieving faster convergence than pure bisection."
  },
  {
    "objectID": "reference/hybrid.hybrid.html#see-also",
    "href": "reference/hybrid.hybrid.html#see-also",
    "title": "hybrid.hybrid",
    "section": "",
    "text": "bisection_find_roots : Bisection-based root search for detecting multiple candidate roots. newton1d : Newton-Raphson method for fast local root refinement."
  },
  {
    "objectID": "reference/hybrid.hybrid.html#examples",
    "href": "reference/hybrid.hybrid.html#examples",
    "title": "hybrid.hybrid",
    "section": "",
    "text": "&gt;&gt;&gt; f = lambda x: x**2 - 4\n&gt;&gt;&gt; df = lambda x: 2*x\n&gt;&gt;&gt; roots = hybrid(f, df, -3, 3, tol1=1e-6, tol2=1e-12)\n&gt;&gt;&gt; sorted(roots)\n[-2.0, 2.0]\n&gt;&gt;&gt; f = lambda x: x**3 - x\n&gt;&gt;&gt; df = lambda x: 3*x**2 - 1\n&gt;&gt;&gt; roots = hybrid(f, df, -2, 2, tol1=1e-6, tol2=1e-12)\n&gt;&gt;&gt; sorted(roots)\n[-1.0, 0.0, 1.0]"
  }
]